#ifndef HTML_H#define HTML_H#include "HTMLTokenizer.h"#include "HTMLToken.h"#include "StopWords.h"#include "URL.h"#include "Page.h"#include "BST.h"#include "Pair.h"#include "URLInputStream.h"//template <typename T, typename U> class Pair;//! This class is responsible for parsing the HTML file.class HTMLparser{	friend class TestHTMLparser;	public:			HTMLparser();				//! parse and download the web page, storing words, URL's, and page		//! @param url to download page from		//! @param stop words not to index		HTMLparser(URL* url, StopWords* stopWords);				//! @return true if parsing was successful		bool success();				~HTMLparser();				//! @return page object with URL and description already loaded		//! @throws exception if the HTML has not been parsed yet		Page getPage();				//!@return HashMap of words and number of times found found on the page		//! @throws exception if the HTML has not been parsed yet		BST< Pair<std::string,int> >* getWords();				//!@return LinkedList of URL's found on the page		//! @throws exception if the HTML has not been parsed yet		LinkedList<URL>* getURLs();					private:			//keep track of whether we are in HTML; relevant for URL processing		bool inHTML;		//keep track of whether we are in body; relevant for text and title processing		bool inBody;		//keep track of whether we are in title; relevant for text and title processing		bool inTitle;		//keep track of whether we are in h1 though h6; relevant for title processing		bool inHeader;		//if we finish processing a header, then set this to true. Should only		//count the first header		bool headerDone;		//keep track of whether we are in a script; need to ignore these		bool inScript;				string titleString;		string headerString;		string first100;		int first100length;				//!@param text contained in start tag		//!set processing tags according to start tag value		void processStart(string tokenValue);				//!@param text contained in end tag		//!set processing tags according to end tag value		void processEnd(string tokenValue);				//!@param text from token		//!index text and add to titles		void processText(string tokenValue);				//!@param link token		//!@param url created from token		//!resolve link and add to URL list		void processLink(HTMLToken token, URL* url);				//!@return true if current flags mean not to process anything		bool noProcess();			//!sets the title based on the best available source (title, headers, and first 100 chars)		void setTitle();				//!While building the first100 characters title, use this function to properly count		//!and append to it.		//!@param current first100 string		//!@param current length of first100		//!@param text to append to first100		void addTo100(string & first100, int & first100length, string text);				//!@return true if the string is one of h1 through h6		bool isHeader(std::string text);				static bool isWordChar(char c);				//!@ text to separate into words and add to index		void index(const std::string& text);				//!@param word to add to the index		//!only adds the word if it is not in the stopwords list		void indexWord(const std::string word);				static const int first100target = 100;				LinkedList<URL>* URLs;		BST< Pair<std::string,int> >* words;		URLInputStream* urlInputStream;		HTMLTokenizer* tokenizer;		Page page;		StopWords* stopWords;		bool parseSuccess;};#endif